"""
Data models and schemas for the AI Coder system
"""
from typing import List, Dict, Optional, Any, Literal
from pydantic import BaseModel, Field, field_validator
from enum import Enum
from datetime import datetime, timezone


class AgentRole(str, Enum):
    """Agent roles in the multi-agent system"""
    # Basic workflow agents (legacy)
    PLANNER = "planner"
    CODER = "coder"
    TESTER = "tester"
    REVIEWER = "reviewer"
    
    # Phase 1: Discovery & Analysis
    REQUIREMENTS_ANALYST = "requirements_analyst"
    RESEARCH = "research"
    DOMAIN_EXPERT = "domain_expert"
    
    # Phase 2: Design & Planning
    ARCHITECT = "architect"
    MODULE_DESIGNER = "module_designer"
    COMPONENT_DESIGNER = "component_designer"
    DATABASE_DESIGNER = "database_designer"
    UI_DESIGNER = "ui_designer"
    
    # Phase 3: Implementation
    CODE_GENERATOR = "code_generator"
    DOCUMENTATION = "documentation"
    CONFIGURATION = "configuration"
    
    # Phase 4: Quality Assurance
    TEST_GENERATOR = "test_generator"
    DEBUGGER = "debugger"
    SECURITY_AUDITOR = "security_auditor"
    PERFORMANCE_ANALYZER = "performance_analyzer"
    CODE_REVIEWER = "code_reviewer"
    
    # Phase 5: Validation & Deployment
    EXECUTOR = "executor"
    INTEGRATION_TESTER = "integration_tester"
    DEPLOYMENT_PLANNER = "deployment_planner"
    
    # Note: Phase 6 (Monitoring) removed - not needed for core code generation


class MessageType(str, Enum):
    """Types of messages in MCP"""
    REQUEST = "request"
    RESPONSE = "response"
    NOTIFICATION = "notification"
    ERROR = "error"


class CodeRequest(BaseModel):
    """Request to generate code"""
    description: str = Field(..., description="Software description and requirements")
    language: Optional[str] = Field(default="python", description="Target programming language")
    framework: Optional[str] = Field(default=None, description="Framework to use")
    requirements: Optional[List[str]] = Field(default=[], description="Specific requirements")

    class Config:
        json_schema_extra = {
            "example": {
                "description": "Create a REST API for a todo list application",
                "language": "python",
                "framework": "fastapi",
                "requirements": ["CRUD operations", "SQLite database", "Authentication"]
            }
        }


class AgentMessage(BaseModel):
    """Message passed between agents via MCP"""
    id: str = Field(..., description="Unique message ID")
    sender: AgentRole = Field(..., description="Agent sending the message")
    recipient: Optional[AgentRole] = Field(None, description="Target agent (None for broadcast)")
    message_type: MessageType = Field(..., description="Type of message")
    content: Dict[str, Any] = Field(..., description="Message content")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    parent_id: Optional[str] = Field(None, description="ID of message this responds to")


class Plan(BaseModel):
    """Implementation plan created by Planner agent (Legacy - prefer FeaturePlan for new code)"""
    overview: str = Field(..., description="High-level overview of the plan")
    steps: List[str] = Field(..., description="Detailed implementation steps")
    file_structure: Dict[str, str] = Field(..., description="Proposed file structure")
    dependencies: List[str] = Field(default=[], description="Required dependencies")
    estimated_complexity: Literal["simple", "medium", "complex"] = Field(default="medium", description="Complexity estimate (simple/medium/complex)")
    
    @field_validator('estimated_complexity', mode='before')
    @classmethod
    def normalize_complexity(cls, v):
        """Normalize estimated_complexity to valid values"""
        if not v or not isinstance(v, str):
            return "medium"
        
        v_lower = str(v).lower().strip()
        
        # Handle empty strings, null, none
        if not v_lower or v_lower in ["null", "none", "", "undefined"]:
            return "medium"
        
        # Map invalid values to valid ones (including legacy values)
        complexity_map = {
            "simple": "simple",
            "medium": "medium",
            "complex": "complex",
            "low": "simple",      # Map legacy 'low' to 'simple'
            "high": "complex",    # Map legacy 'high' to 'complex'
            "easy": "simple",
            "moderate": "medium",
            "difficult": "complex",
            "hard": "complex"
        }
        
        return complexity_map.get(v_lower, "medium")


class GeneratedCode(BaseModel):
    """Code generated by Coder agent"""
    filename: str = Field(..., description="Name of the file")
    filepath: str = Field(..., description="Full file path")
    content: str = Field(..., description="Code content")
    language: str = Field(..., description="Programming language")
    description: str = Field(..., description="Description of what this file does")


class TestCase(BaseModel):
    """Test case generated by Tester agent"""
    name: str = Field(..., description="Test case name")
    filepath: str = Field(..., description="Test file path")
    content: str = Field(..., description="Test code content")
    test_type: str = Field(..., description="Type of test (unit/integration/e2e)")
    target_file: Optional[str] = Field(None, description="File being tested")


class ReviewFeedback(BaseModel):
    """Code review feedback from Reviewer agent"""
    file: str = Field(..., description="File being reviewed")
    issues: List[str] = Field(default=[], description="Issues found")
    suggestions: List[str] = Field(default=[], description="Improvement suggestions")
    quality_score: float = Field(..., ge=0, le=10, description="Quality score out of 10")
    approved: bool = Field(..., description="Whether code is approved")


class LLMUsage(BaseModel):
    """LLM usage statistics"""
    model: str = Field(..., description="Model used")
    prompt_tokens: int = Field(..., description="Tokens in prompt")
    completion_tokens: int = Field(..., description="Tokens in completion")
    total_tokens: int = Field(..., description="Total tokens used")
    cost: Optional[float] = Field(None, description="Estimated cost in USD")


class AgentActivity(BaseModel):
    """Activity log for an agent"""
    agent: AgentRole = Field(..., description="Agent role")
    action: str = Field(..., description="Action performed")
    status: str = Field(..., description="Status (in_progress/completed/failed)")
    start_time: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    end_time: Optional[datetime] = Field(None)
    llm_usage: Optional[LLMUsage] = Field(None)


class CodeGenerationResult(BaseModel):
    """Final result of the code generation process"""
    request_id: str = Field(..., description="Unique request ID")
    status: str = Field(..., description="Generation status")
    plan: Optional[Plan] = Field(None, description="Implementation plan")
    code_files: List[GeneratedCode] = Field(default=[], description="Generated code files")
    test_files: List[TestCase] = Field(default=[], description="Generated test files")
    review: Optional[ReviewFeedback] = Field(None, description="Code review feedback")
    agent_activities: List[AgentActivity] = Field(default=[], description="Agent activity log")
    total_llm_usage: Dict[str, int] = Field(default={}, description="Total LLM usage across all agents")
    total_cost: float = Field(default=0.0, description="Total estimated cost")
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    completed_at: Optional[datetime] = Field(None)

    class Config:
        json_schema_extra = {
            "example": {
                "request_id": "abc-123",
                "status": "completed",
                "total_llm_usage": {
                    "total_calls": 8,
                    "total_tokens": 12500
                },
                "total_cost": 0.25
            }
        }


class ErrorResponse(BaseModel):
    """Error response"""
    error: str = Field(..., description="Error message")
    details: Optional[Dict[str, Any]] = Field(None, description="Additional error details")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
